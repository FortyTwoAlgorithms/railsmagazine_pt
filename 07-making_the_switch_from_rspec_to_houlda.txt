Fazendo a troca de RSpec para Shoulda
por Dan Pickett

Graças a Bryan Liles, agora sabemos a resposta para a pergunta,
 "Quando devemos testar?".
Porém, uma importante questão ainda permanece: "Como devo testar?".
Enquanto esta pergunta ainda é muito discutida, existem alguns
frameworks disponíveis para nos ajudar.
Por um bom tempo, eu fui casado com RSpec. Escrever comportamentos
funcionou bem para a minha rotina, e comecei a gostar da sintaxe.
Sem dúvida, fomos feitos um para o outro e iríamos viver felizes
para sempre no mundo TDD. No entanto, a lua de mel durou pouco.
As falhas aleatórias na especificação e os segredos por trás da
Spec::Runner levantaram algumas dúvidas. Um caso secreto de testes
se seguiu.
Comecei a usar Shoulda em todos os meus projetos particulares.
Macros e assertions customizáveis me afastaram do RSpec.
Nos últimos dois meses, todos os meus projetos começaram com
Shoulda, e desde então nunca olhei para trás.


Porque fiz a troca

Antes de descobrir Shoulda, minhas ferramentas para testes
consistiam em RSpec para comportamentos, factory_girl para
geração de model, autotest para manter os testes rodando
e Mocha para mocking e stubbing. Juntas, essas ferramentas
funcionaram muito bem para mim.
Numa determinada semana, eu estava codificando nosso
projeto para o Rails Rumble 2008. Com um bom ritmo TDD,
eu estava [passando] pelos comportamnetos e suas
implementações correspondentes. Eu estava escrevendo
factories e [buscadores] stubbing como se isso fosse
[o negócio de ninguém].
Enquanto continuava, percebi que precisava de um mecanismo
de autenticação, e devido ao pouco tempo disponível, comecei
a integração do RESTful Authentication.
O que se seguiu foi uma falha total. Meu precioso tempo
de 48 horas codificando pesado foi perdido. Por quê?
O RESTful Authentication gerou uma série de Specs usando
o framework nativo de mocking do RSpec. E como eu estava
usando Mocha, as specs geradas para a autenticação falharam.
Depois de perder algumas horas do meu precioso tempo, não
consegui fazer diferentes specs usarem diferentes frameworks
para mocking e stubbing. Por quê? Spec::Runner possui uma opção
de configuração chamada mock_with (mockar com). Infelizmente,
sem muito hacking, eu não consegui alterar essa configuração
[pra frente e para trás] para exemplos específicos. Cheguei
então à conclusão que usar mais de um framework mock para
a mesma suíte de testes não era fácil. Na minha opinião, esse
é um problema fundamental na forma como o RSpec é escrito.
Não tive tempo para alterar os testes gerados pelo RESTful
Authentication para usar Mocha, e eu precisava da cobertura
para algumas partes de autenticação da minha aplicação.
Derrotado, tive que comentar todos os meus testes de
autenticação e perdi a cobertura em algumas partes de
autenticação da minha aplicação. Essa foi a gota d'água
entre eu e a Spec::Runner.


Eu deveria usar Shoulda
Voltando para Test::Unit equipado com um framework tem sido
ótimo. Você pode mesclar testes Test::Unit padrões com
blocos shoulda. Você pode construir suas classes abstratas
de testes com métodos helper e macros. Em geral, é
muito mais confortável trabalhar com uma estrutura
de classe em minha suíte de testes. Além disso alguns dos
meus specs modelos para testes unitários com Shoulda, macros
ActiveRecord para validação diminuíram o número de linhas
significativamente. Ficou fácil escrever assertions
customizadas de novo, e não preciso mais adicionar ou
remover um monte de arquivos depois de executar
script/generate.

describe Band do
  it "should have a name" do
    band = Factory.build(:band, :name => "")
    band.save.should be_false
    band.errors.size.should eql(1)
  end
  it "should have a unique name" do
    band = Factory(:band)
    band_2 = Factory.build(:band, :name => band.name)

    band_2.save.should be_false
  end
  it "could have a list of albums" do
    band = Factory(:band)
    album = Factory(:album, :band => band)
    album_2 = Factory(:album, :band => band)

    band.albums.size.should eql(2)
  end
end

ficou apenas:

class BandTest < ActiveSupport::TestCase
  context "a band" do
    setup do
      @band = Factory(:band)
	end
    should_require_attribute :name
    should_require_unique_attribute :name
    should_have_many :albums
  end
end

ActiveRecord::Macros fornece muitas utilidades. Achei
should_have_db_column e as associações de macros
antes de gerar as migrations extremamente úteis na
implementação dos meus models. should_protect_atribute
também é um grande utilitário que ajuda a proteger
chaves estrangeiras e outros atributos de segurança
das atribuições em massa.


O que eu deveria saber
Tem algumas coisas que aprendi durante o processo
que eu gostaria de ter descobrido antes.
Eu geralmente não uso as macros do Shoulda para meus
testes funcionais.
Eles sempre geram códigos ruins quando quero setar
expectations primeiro para disparar o request. Por
exemplo, no contexto abaixo:

  context "when creating a user" do
    setup do
      post :create, :user => {:login => "jsmith",
       :password => "secret",
       :password_confirmation => "secret"}
    end
    should_respond_with :redirect
  end

Se eu quiser adicionar uma expectation para o controller
tentar salvar o registro, eu não posso realmente concluir
isso claramente porque o request é disparado no bloco
setup. Geralmente eu apenas escrevo meus próprios
statements para os testes funcionais. O exemplo acima,
adicionado a expectation para salvar vai ficar como:

  context "when creating a user" do
    setup do
      @user = Factory.build(:user)
      User.stubs(:new).returns(@user)
    end
    should "redirect" do
      do_create_post
      assert_response :redirect
    end
    should "attempt to save the user" do
      @user.expects(:save).returns(true)
      do_create_post
    end
  end

  def do_create_post(user_attrs = {})
    post :create, :user => {:login => "jsmith", :password => "secret", :password_confirmation => "secret"}.merge(user_attrs)
  end


Além disso, o método validates_uniqueness_of_requires do
Shoulda requer um registro na tabela para executar. Quando
o teste quebrar, será fácil de identificar, [mas isso pode te
marcar um pouco].
Existe um ótimo projeto de autoria do Jeremy McAnally no
GitHub chamado Matchy. Ele fornece algumas das belezas da
sintaxe das declarações should do RSpec dentro da Test::Unit.
Isso tem sido útil na mudança das minhas specs para Test::Unit
 e Shoulda.
Mas cuidado, eu acredito que should =~ /regex/ nunca falhou
(está na minha lista todo escrever um patch).


O que eu sinto falta
RSpec me serviu bem por um bom tempo. Agora que mudei para
Shoulda, tem algumas coisas para esquecer definitivamente.
O bloco before(:all) era muito bom no RSpec. O bloco setup
do Shoulda executa para cada declaração should, onde
before(:all) irá executar uma vez para uma lista de exemplos.
Executando uma grande suíte de testes, o ganho de performance
com um before(:all) em vez de um before(:each) foi ótimo
quando disponível.
Enquanto isso não é realmente um problema na implementação
do Shoulda, eu perdi a capacidade de executar exemplos
focados no TextMate. O item Run Focused Should do pacote do
Shoulda para o TextMate sempre dispara um SystemStackError.
Eu consigo rodar exemplos individuais por linha de comando,
mas me incomoda não conseguir rodar no meu editor. Por outro
lado, gostei da janela Rspec Results do TextMate.
Enquanto o principal suporte para helpers de testes está
ficando melhor com classes como ActionView::TestCase, testes
Helper foram um pouco mais intuitivos no RSpec para mim. Testando
meus helpers com Shoulda, isso levou [um hack e um patch to
core] a fim de receber métodos *_path e *_url funcionando
para ActionView::TestCase.



O que eu deveria saber
RSpec e Shoulda são ótimos frameworks construídos por ótimos
desenvolvedores. Se você está usando um framework e você
está escrevendo testes antes de implementar, você está no
caminho certo.
Cada framework tem seus prós e contras, e minha intenção aqui
não foi ser persuasivo sobre um framework específico, mas
para documentar minha experiência fazendo essa troca.
Se você está considerando a mudança do RSpec para o Shoulda ou
vice-versa, considere esses elementos cuidadosamente e qual
é o custo de migrar toda a sua suíte de testes. Ambos fazem
bem o trabalho, e eu optei por deixar alguns dos meus projetos
com uma suíte de testes RSpec simplesmente porque o tempo
investido em migrar para Shoulda iria ser muito grande e
trabalhoso. Como um desenvolvedor você deve sempre considerar
o custo do seu trabalho relativo ao seu benefício.
Fale com seu time e garanta que todos estejam confortáveis e
sejam competentes o suficiente antes de utilizar um novo
framework.
E não se esqueça, TATFT (test all the fucking time).
